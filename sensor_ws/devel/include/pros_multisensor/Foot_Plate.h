// Generated by gencpp from file pros_multisensor/Foot_Plate.msg
// DO NOT EDIT!


#ifndef PROS_MULTISENSOR_MESSAGE_FOOT_PLATE_H
#define PROS_MULTISENSOR_MESSAGE_FOOT_PLATE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace pros_multisensor
{
template <class ContainerAllocator>
struct Foot_Plate_
{
  typedef Foot_Plate_<ContainerAllocator> Type;

  Foot_Plate_()
    : F_area1(0.0)
    , x_area1(0.0)
    , y_area1(0.0)
    , F_area2(0.0)
    , x_area2(0.0)
    , y_area2(0.0)
    , F_area3(0.0)
    , x_area3(0.0)
    , y_area3(0.0)
    , F_net(0.0)
    , x_net(0.0)
    , y_net(0.0)
    , contact(0)  {
    }
  Foot_Plate_(const ContainerAllocator& _alloc)
    : F_area1(0.0)
    , x_area1(0.0)
    , y_area1(0.0)
    , F_area2(0.0)
    , x_area2(0.0)
    , y_area2(0.0)
    , F_area3(0.0)
    , x_area3(0.0)
    , y_area3(0.0)
    , F_net(0.0)
    , x_net(0.0)
    , y_net(0.0)
    , contact(0)  {
  (void)_alloc;
    }



   typedef float _F_area1_type;
  _F_area1_type F_area1;

   typedef float _x_area1_type;
  _x_area1_type x_area1;

   typedef float _y_area1_type;
  _y_area1_type y_area1;

   typedef float _F_area2_type;
  _F_area2_type F_area2;

   typedef float _x_area2_type;
  _x_area2_type x_area2;

   typedef float _y_area2_type;
  _y_area2_type y_area2;

   typedef float _F_area3_type;
  _F_area3_type F_area3;

   typedef float _x_area3_type;
  _x_area3_type x_area3;

   typedef float _y_area3_type;
  _y_area3_type y_area3;

   typedef float _F_net_type;
  _F_net_type F_net;

   typedef float _x_net_type;
  _x_net_type x_net;

   typedef float _y_net_type;
  _y_net_type y_net;

   typedef int8_t _contact_type;
  _contact_type contact;





  typedef boost::shared_ptr< ::pros_multisensor::Foot_Plate_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::pros_multisensor::Foot_Plate_<ContainerAllocator> const> ConstPtr;

}; // struct Foot_Plate_

typedef ::pros_multisensor::Foot_Plate_<std::allocator<void> > Foot_Plate;

typedef boost::shared_ptr< ::pros_multisensor::Foot_Plate > Foot_PlatePtr;
typedef boost::shared_ptr< ::pros_multisensor::Foot_Plate const> Foot_PlateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::pros_multisensor::Foot_Plate_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::pros_multisensor::Foot_Plate_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::pros_multisensor::Foot_Plate_<ContainerAllocator1> & lhs, const ::pros_multisensor::Foot_Plate_<ContainerAllocator2> & rhs)
{
  return lhs.F_area1 == rhs.F_area1 &&
    lhs.x_area1 == rhs.x_area1 &&
    lhs.y_area1 == rhs.y_area1 &&
    lhs.F_area2 == rhs.F_area2 &&
    lhs.x_area2 == rhs.x_area2 &&
    lhs.y_area2 == rhs.y_area2 &&
    lhs.F_area3 == rhs.F_area3 &&
    lhs.x_area3 == rhs.x_area3 &&
    lhs.y_area3 == rhs.y_area3 &&
    lhs.F_net == rhs.F_net &&
    lhs.x_net == rhs.x_net &&
    lhs.y_net == rhs.y_net &&
    lhs.contact == rhs.contact;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::pros_multisensor::Foot_Plate_<ContainerAllocator1> & lhs, const ::pros_multisensor::Foot_Plate_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace pros_multisensor

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::pros_multisensor::Foot_Plate_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::pros_multisensor::Foot_Plate_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::pros_multisensor::Foot_Plate_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::pros_multisensor::Foot_Plate_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::pros_multisensor::Foot_Plate_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::pros_multisensor::Foot_Plate_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::pros_multisensor::Foot_Plate_<ContainerAllocator> >
{
  static const char* value()
  {
    return "e96a18f41c104b55b04d72c552abf512";
  }

  static const char* value(const ::pros_multisensor::Foot_Plate_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xe96a18f41c104b55ULL;
  static const uint64_t static_value2 = 0xb04d72c552abf512ULL;
};

template<class ContainerAllocator>
struct DataType< ::pros_multisensor::Foot_Plate_<ContainerAllocator> >
{
  static const char* value()
  {
    return "pros_multisensor/Foot_Plate";
  }

  static const char* value(const ::pros_multisensor::Foot_Plate_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::pros_multisensor::Foot_Plate_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float32 F_area1\n"
"float32 x_area1\n"
"float32 y_area1\n"
"float32 F_area2\n"
"float32 x_area2\n"
"float32 y_area2\n"
"float32 F_area3\n"
"float32 x_area3\n"
"float32 y_area3\n"
"float32 F_net\n"
"float32 x_net\n"
"float32 y_net\n"
"int8 contact\n"
;
  }

  static const char* value(const ::pros_multisensor::Foot_Plate_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::pros_multisensor::Foot_Plate_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.F_area1);
      stream.next(m.x_area1);
      stream.next(m.y_area1);
      stream.next(m.F_area2);
      stream.next(m.x_area2);
      stream.next(m.y_area2);
      stream.next(m.F_area3);
      stream.next(m.x_area3);
      stream.next(m.y_area3);
      stream.next(m.F_net);
      stream.next(m.x_net);
      stream.next(m.y_net);
      stream.next(m.contact);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Foot_Plate_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::pros_multisensor::Foot_Plate_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::pros_multisensor::Foot_Plate_<ContainerAllocator>& v)
  {
    s << indent << "F_area1: ";
    Printer<float>::stream(s, indent + "  ", v.F_area1);
    s << indent << "x_area1: ";
    Printer<float>::stream(s, indent + "  ", v.x_area1);
    s << indent << "y_area1: ";
    Printer<float>::stream(s, indent + "  ", v.y_area1);
    s << indent << "F_area2: ";
    Printer<float>::stream(s, indent + "  ", v.F_area2);
    s << indent << "x_area2: ";
    Printer<float>::stream(s, indent + "  ", v.x_area2);
    s << indent << "y_area2: ";
    Printer<float>::stream(s, indent + "  ", v.y_area2);
    s << indent << "F_area3: ";
    Printer<float>::stream(s, indent + "  ", v.F_area3);
    s << indent << "x_area3: ";
    Printer<float>::stream(s, indent + "  ", v.x_area3);
    s << indent << "y_area3: ";
    Printer<float>::stream(s, indent + "  ", v.y_area3);
    s << indent << "F_net: ";
    Printer<float>::stream(s, indent + "  ", v.F_net);
    s << indent << "x_net: ";
    Printer<float>::stream(s, indent + "  ", v.x_net);
    s << indent << "y_net: ";
    Printer<float>::stream(s, indent + "  ", v.y_net);
    s << indent << "contact: ";
    Printer<int8_t>::stream(s, indent + "  ", v.contact);
  }
};

} // namespace message_operations
} // namespace ros

#endif // PROS_MULTISENSOR_MESSAGE_FOOT_PLATE_H
